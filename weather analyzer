# analysis.py
# Author - Lakshay

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# Config
# -----------------------------
DATA_PATH = "data/india_weather.csv"   #  defined CSV file path
OUTPUT_DIR = "outputs"
CITY_FILTER = "Delhi"                  # set None to analyze all cities
SEED = 42

os.makedirs(OUTPUT_DIR, exist_ok=True)
np.random.seed(SEED)
sns.set(style="whitegrid", context="notebook")

# -----------------------------
# Task 1: Data acquisition & loading
# -----------------------------
# Load dataset directly from local CSV
df = pd.read_csv(DATA_PATH)

print("Path to dataset file:", DATA_PATH)
print("\n=== Head ===")
print(df.head())
print("\n=== Info ===")
print(df.info())
print("\n=== Describe ===")
print(df.describe(include="all"))

# -----------------------------
# Task 2: Cleaning & processing
# -----------------------------
# Standardize column names (lowercase, underscores)
df.columns = (
    df.columns
    .str.strip()
    .str.lower()
    .str.replace(" ", "_")
    .str.replace("-", "_")
)

# Identify possible date & metric columns
candidate_date_cols = [c for c in df.columns if "date" in c or "time" in c]
date_col = candidate_date_cols[0] if candidate_date_cols else None
if date_col is None:
    raise ValueError("No date column found. Please rename your date column to 'date'.")

# Convert date to datetime and set index
df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
df = df.dropna(subset=[date_col]).sort_values(by=date_col)
df = df.set_index(date_col)

# Choose relevant columns
col_map_candidates = {
    "tmax": ["temperature_2m_max", "tmax", "temp_max", "max_temp"],
    "tmin": ["temperature_2m_min", "tmin", "temp_min", "min_temp"],
    "rain": ["rain_sum", "rainfall", "precipitation", "precip_sum"],
    "humidity": ["relative_humidity_2m_mean", "humidity", "rh_mean", "avg_humidity"],
}

def pick_column(df, candidates):
    for c in candidates:
        if c in df.columns:
            return c
    return None

col_tmax = pick_column(df, col_map_candidates["tmax"])
col_tmin = pick_column(df, col_map_candidates["tmin"])
col_rain = pick_column(df, col_map_candidates["rain"])
col_hum  = pick_column(df, col_map_candidates["humidity"])

selected_cols = [c for c in [col_tmax, col_tmin, col_rain, col_hum, "city"] if c is not None and c in df.columns]
df = df[selected_cols]

# Handle missing values
numeric_cols = [c for c in df.columns if c != "city"]
rain_like = [col_rain] if col_rain else []
non_rain = [c for c in numeric_cols if c not in rain_like]

df[non_rain] = df[non_rain].ffill().bfill()
if col_rain:
    df[col_rain] = df[col_rain].fillna(0)

# Optional: filter by city
if "city" in df.columns and CITY_FILTER is not None:
    df = df[df["city"].str.lower() == CITY_FILTER.lower()]

# -----------------------------
# Task 3 onwards (statistics, visualization, grouping, export)
# -----------------------------
# ... (keep the rest of your original code unchanged)
